问答

Q1:当异常被抛出时，程序的控制权会如何转换？
A1:当异常被抛出时，程序的控制权会从当前的try区块离开，然后将控制权交给在try区块之后
某一个符合类型的catch异常处理程序区块(假如存在的话)

Q2:一次捕获所有异常的方法？
A2:catch(...)

Q3:通用型程序设计？
A3:模板主要提供了"参数化类型"的功能，此功能最大的作用在于将函数或类中通用的类型视为
一种参数，当使用模板创建函数或类时，只需将特定的数据类型(如int)带入，即可产生该特定
类型的函数或类，所以模板的设计概念也被称为"通用型程序设计"

Q4:类模板的声明语法？
A4:类名称 <数据类型> 对象名称(参数);

Q5:为什么派生类所继承的基类后面需加"<数据类型>"？
A5:派生类继承前必须先声明类模板template，这样编译程序才会认为是继承模板，
而且在继承的基类后面需加<数据类型>，这是类模板的特殊语法，目的是要确定基类为哪一种
数据类型，此数据类型可以为内建数据类型，如int、float等，也可以是模板参数。

Q6:模板函数的声明格式？
A6:
template <class 模板形式参数1, class 模板形式参数2, ...>
返回数据类型 函数名称(参数1, 参数2, ...)
{
    //函数内的语句区块
}

Q7:C++的语法中最常见的异常情况由哪些？
A7:除数为0、超过数组下标边界、发生溢出、无效的函数参数、使用new时无法获取内存。

Q8:程序抛出异常时，程序的控制权可以再回到原来的抛出点吗？
A8:不会。

Q9:异常处理区块的排列顺序是否会影响如何处理某个异常？
A9:会。

Q10:使用catch(...)捕获所有的异常有什么优点和缺点？
A10:优点是可以捕获所有异常，缺点是由于catch(...)没有使用参数，无法得知错误的原因。

Q11:使用new来分配而发生错误时，需要调用一个可以处理后续问题的函数，这个函数工作是什么？
A11:
1、将其他所分配的内存清除，以便获取更多可以使用的内存。
2、当发生分配内存错误时可抛出一个bad_alloc内存。
3、可调用abort或exit函数来结束程序的运行。

Q12:一个try区块可以对应多个catch区块，有什么先决条件吗？
A12:try区块与catch区块之间不能含有任何运算符或表达式。

Q13:在嵌套try区块中，若内外层catch区块都未能捕获异常，则该异常情况最后如何处理？
A13:交由标准函数库中的terminate()函数处理。

Q14:非类型参数模板中的非类型参数有什么含义？
A14:非类型参数即模板参数为固定类型的参数，在模板中可直接当成常数值来使用。

Q15:类模板对象的声明必须在类名称后加上数据类型，并用尖括号"<>"包含起来，其用意是什么？
A15:指定模板参数的数据类型。

Q16:判断对错，错误说明理由。
A16:
1、模板函数的友元函数必须是一个模板函数。
错。它必须是一个非模板函数
2、某个类模板拥有单独一个static数据成员，产生出几个类模板，每个类模板都会分享
此类模板的static数据成员。
错。形式化类型参数名称在模板函数中不需要是唯一的。
3、一个模板函数可将另一个模板函数用相同的函数名称加以重载。
对。

Q17:非类型参数类模板的作用是什么？
A17:可以定义一个固定大小的类模板，就像是提供数组下标值一样。非类型参数必须是在编译时
才会知道值的"整数"值。